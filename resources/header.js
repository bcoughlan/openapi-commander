#!/usr/bin/env node
/*
 * This code is generated by openapi-commander. Do not modify this file.
 */

/* eslint-disable no-unused-vars */

const fs = require('fs/promises')
const { Command, Argument, Option } = require('commander')

const COMMAND_NAME = 'COMMAND_NAME_TO_BE_REPLACED'
const COMMAND_NAME_ENV_VARS = 'COMMAND_NAME_ENV_VARS_TO_BE_REPLACED'

const program = new Command(COMMAND_NAME)
program.allowExcessArguments(false)

function httpRequest(url, { method, body, headers }) {
  return new Promise((resolve, reject) => {
    const client = url.startsWith('https') ? require('https') : require('http')
    const request = client.request(url, { headers, method }, (response) => {
      const body = []
      response.on('data', (chunk) => body.push(chunk))
      response.on('end', () => {
        resolve({ body: body.join(''), status: response.statusCode, headers: response.headers })
      })
    })
    request.on('aborted', (err) => reject(err))
    request.on('error', (err) => reject(err))
    if (body) request.write(body)
    request.end()
  })
}

function removeNullAndUndefined(obj) {
  var propNames = Object.getOwnPropertyNames(obj);
  for (var i = 0; i < propNames.length; i++) {
    var propName = propNames[i];
    if (obj[propName] === null || obj[propName] === undefined) {
      delete obj[propName];
    }
  }
}

function emptyRequestParams() {
  return {
    pathParams: {},
    queryParams: [],
    headers: {},
    body: undefined
  }
}

async function request(method, defaultServer, path, { pathParams, queryParams, headers, body }) {
  removeNullAndUndefined(headers)
  headers.Accept = '*/*'

  const globalOpts = getGlobalOptions()
  if (globalOpts.header) {
    const headerLookup = Object.fromEntries(Object.keys(headers).map(h => [h.toLowerCase(), h]))

    for (const globalHeader of globalOpts.header) {
      const [key, value] = globalHeader.split(':', 2)
      if (!value) {
        console.error('Invalid header. It should be in the format "key: value":', globalHeader)
        process.exitCode = 1
        return
      }
      const mappedKey = headerLookup[key.toLowerCase()] ?? key
      headers[mappedKey] = value.trimStart()
    }
  }

  const baseUrl = globalOpts.server ?? defaultServer
  if (globalOpts.auth) headers.Authorization = globalOpts.auth

  try {
    var fullUrl = new URL(baseUrl)
  } catch (err) {
    err.message = `Invalid base URL: ${baseUrl}`
    throw err
  }

  const definedParams = queryParams.filter(e => e[1] !== undefined && e[1] !== null)
  fullUrl.search = new URLSearchParams(definedParams).toString()
  if (!fullUrl.pathname.endsWith('/')) fullUrl.pathname += '/'
  fullUrl.pathname += path.split('/').map(part => {
    if (part.startsWith('{') && part.endsWith('}')) {
      return encodeURIComponent(pathParams[part.substring(1, part.length - 1)])
    }
    return part
  }).join('/').slice(1)

  if (globalOpts.print === 'curl') {
    const shellEscape = function (str) {
      return "'" + str.replace("'", "'\\''") + "'"
    }

    const curl = ['curl']
    if (method !== 'GET') curl.push(`-X ${method.toUpperCase()}`)
    for (const [key, value] of Object.entries(headers)) {
      curl.push(`-H ${shellEscape(`${key}: ${value}`)}`)
    }
    curl.push(shellEscape(fullUrl.toString()))
    if (body) curl.push(`-d ${shellEscape(body)}`)
    console.log(curl.join(' '))
  } else if (globalOpts.print === 'plain') {
    console.log(method.toUpperCase(), fullUrl.toString())
    for (const [name, value] of Object.entries(headers)) {
      console.log(`${name}: ${value}`)
    }
    if (body) {
      console.log()
      console.log(body)
    }
  } else {
    // eslint-disable-next-line no-undef
    const response = await httpRequest(fullUrl.toString(), { method, body, headers })
    console.error(`Status: ${response.status}`) //stderr so body can be piped

    if (!response.status || response.status < 200 || response.status >= 400) {
      process.exitCode = 1
    }

    if (globalOpts.verbose) {
      for (const [key, value] of Object.entries(response.headers)) {
        console.log(`${key}: ${value}`)
      }
    }

    if (response.headers['content-type']?.startsWith('application/json')) {
      try {
        console.log(JSON.stringify(JSON.parse(response.body), null, 2))
      } catch (e) {
        //For misbehaving APIs
        console.log(response.body)
      }
    } else {
      console.log(response.body)
    }
  }
}

function printExamples(examplesMapping) {
  for (const [type, examples] of Object.entries(examplesMapping)) {
    for (const example of examples) {
      console.log(`Example for ${type}:`)
      console.log(example)
    }
  }
}

function getGlobalOptions() {
  const opts = program.opts()
  opts.server = opts.server ?? process.env[`${COMMAND_NAME_ENV_VARS}_SERVER`]
  opts.auth = opts.auth ?? process.env[`${COMMAND_NAME_ENV_VARS}_AUTH`]
  return opts
}

program.addOption(new Option('-p, --print <mode>', 'Print the HTTP request instead of sending it.')
  .choices(['curl', 'plain']))
program.option('-v, --verbose', 'Includes the response headers in the output')
program.option('-s, --server <server>', 'Base URL to use for requests')
program.option('-a, --auth <auth>', 'Authorization header to send')
program.option('-h, --header <header>', 'Set HTTP Header in the format "key: value". ' +
  'Headers set with this option take precedence over any other headers', (p,v) => (v ?? []).concat([p]))
